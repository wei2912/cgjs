\documentclass{article}

\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\qt}[1]{\mbox{`#1'}}
\algrenewcommand{\algorithmicreturn}{\State \textbf{return}}

\title{Week 2: Tic-Tac-Toe}
\author{Benjamin Tan and Ng Wei En}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

Tic-Tac-Toe is a paper-and-pencil game for two players, X and O, who take turns marking the spaces in a 3 x 3 grid. The player who succeeds in placing three respective marks in a horizontal, vertical, or diagonal row wins the game.

In this document, we detail out the API of a Tic Tac Toe implementation.

\section{API}

We define the following objects:

\begin{description}
  \item[TicTacToe] Contains the state of the Tic Tac Toe game.
\end{description}

\subsection{Game}

The `TicTacToe' object contains the following properties and functions:

\begin{description}
  \item[TicTacToe()] Constructor for the Tic Tac Toe object.

  \item[grid] Instance of a Grid object.
  \item[curTurn] Current turn.

  \item[isWin()] Check if any player has won.
  \item[move()] Make the next move.
\end{description}

\subsubsection{TicTacToe()}

`TicTacToe()' is the constructor of the TicTacToe object. It initializes `grid' and `curTurn'.

\subsubsection{grid}

`grid' is a 3 x 3 array of markings. Markings can be either `X', `O' or null, the last one indicating that no marking has been placed.

For a game board of:

\begin{verbatim}
O O X
_ O _
X X X
\end{verbatim}

where `\_' represents an empty square and `O' and `X' represent their respective players, the board is represented as the following array:

\begin{verbatim}
[[`O', `O', `X'],
 [null, `O', null],
 [`X', `X', `X']]
\end{verbatim}

`grid' is initialized to a 3 x 3 array of nulls.

\subsubsection{curTurn}

`curTurn' stores the current turn for the player. Its value can be either `X' or `O'. The first player to go is `X'. Hence, `curTurn' is initialized to `X'.

\subsubsection{isWin()}

`isWin()' checks if the player has already won. The following logic is used to find out if the player has already won:

\begin{algorithm}
\caption{Check if any player has won.}

\begin{algorithmic}[1]
\Procedure{isWin}{}
  \ForAll{$seq \in this.\Call{getPosWinSeqs}{}$}
    \For{$i \gets 0, \Call{length}{seq} - 1$}
      \If{$\lnot seq[i] = seq[i + 1]$}
        $break$
      \EndIf
    \EndFor
    \If{$seq[0] = \qt{X}$}
      \Return $\qt{X}$
    \ElsIf{$seq[0] = \qt{O}$}
      \Return $\qt{O}$
    \EndIf
  \EndFor
  \Return $null$
\EndProcedure
\end{algorithmic}
\end{algorithm}

The first part of our algorithm obtains all sequences of markings which, if equal to either `X' or `O', constitutes as a win for that player. Given the following grid:

\begin{verbatim}
X O X
O X O
X _ _
\end{verbatim}

The following sequences of markings should be obtained:

\begin{verbatim}
// Rows
X O X
O X O
X _ _

// Columns
X O X
O X _
X O _

// Forward Diagonal
X X X
// Backward Diagonal
X X _
\end{verbatim}

The forward diagonal is comprised of only `X'. Hence, it can be concluded that the player `X' has won.

We iterate through all these sequences which the function `getPosWinSeqs' has generated.

For each sequence, if every element in the sequence is equal to each other and equal to either `X' or `O', we return the corresponding players.

The moment a winning sequence is found, the player that has won is returned. Otherwise, the function continues to look through the list of sequences.

If no winning sequence is found, the function returns null, which indicates that the game has not finished.

In order to get the possible winning sequences, we detail out the following algorithm:

\begin{algorithm}
\caption{Obtain the possible winning sequences.}

\begin{algorithmic}[1]
\Procedure{getPosWinSeqs}{}
  \State $rows \gets this.grid$
  \For{$i \gets 0, \Call{length}{this.grid}$}
    \For{$j \gets 0, \Call{length}{this.grid}$}
      \State $cols[i][j] \gets this.grid[j][i]$
    \EndFor
  \EndFor
  \For{$i \gets 0, \Call{length}{this.grid}$}
    \State $fDiag[i] \gets this.grid[i][\Call{length}{this.grid} - i - 1]$
  \EndFor
  \For{$i \gets 0, \Call{length}{this.grid}$}
    \State $bDiag[i] \gets this.grid[i][i]$
  \EndFor
  \Return $rows + cols + [fDiag, bDiag]$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Firstly, the function sets `rows' to the grid itself. This is because the grid itself is defined as a set of rows in order.

Secondly, the function sets `cols' to the transposition of `this.grid'. The following grid:

\begin{verbatim}
O O _
X _ X
O _ X
\end{verbatim}

becomes:

\begin{verbatim}
O X O
O _ _
_ X X
\end{verbatim}

Thirdly, the function sets `fDiag' to the forward diagonal of the array and `bDiag' to the backward diagonal of the array.

Finally, the possible winning sequences are collated and returned as a two-dimensional array.

\subsubsection{move()}

`move()' takes in a position and makes the next move. This algorithm is very trivial to write:

\begin{algorithm}
\caption{Make a move on the game board.}

\begin{algorithmic}[1]
\Procedure{move}{$(i, j)$}
  \If{$i < 0 \lor i \geq \Call{length}{this.grid}$}
    \Return $null$
  \ElsIf{$j < 0 \lor j \geq \Call{length}{this.grid}$}
    \Return $null$
  \ElsIf{$\lnot this.grid[i][j] = null$}
    \Return $null$
  \EndIf

  \State $turn \gets this.curTurn$
  \State $this.grid[i][j] \gets turn$
  \If{$turn = `X'$}
    \State $this.curTurn \gets `O'$
  \ElsIf{$turn = `O'$}
    \State $this.curTurn \gets `X'$
  \EndIf
  \Return $turn$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\end{document}
