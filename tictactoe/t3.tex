\documentclass{article}

\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\qt}[1]{\mbox{`#1'}}
\algrenewcommand{\algorithmicreturn}{\State \textbf{return}}

\title{Week 2: Tic-Tac-Toe}
\author{Benjamin Tan and Ng Wei En}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

Tic-Tac-Toe is a paper-and-pencil game for two players, X and O, who take turns marking the spaces in a 3 x 3 grid. The player who succeeds in placing three respective marks in a horizontal, vertical, or diagonal row wins the game.

\section{Representing a game board}

A 3 x 3 array of markings is used. Markings can be either `X', `O' or null, the last one indicating that no marking has been placed.

For a game board of:

\begin{verbatim}
O O X
_ O _
X X X
\end{verbatim}

where `\_' represents an empty square and `O' and `X' represent their respective players, the board is represented as the following array:

\begin{verbatim}
[[`O', `O', `X'],
 [null, `O', null],
 [`X', `X', `X']]
\end{verbatim}

\section{Checking for a win}

The following logic is used to find out if a player has already won:

\begin{algorithm}
\caption{Check if any player has won.}

\begin{algorithmic}[1]
\Procedure{isWin}{}
  \ForAll{$seq \in this.\Call{getPosWinSeqs}{}$}
    \For{$i \gets 0, \Call{length}{seq} - 1$}
      \If{$\lnot seq[i] = seq[i + 1]$}
        $break$
      \EndIf
    \EndFor
    \If{$seq[0] = \qt{X}$}
      \Return $\qt{X}$
    \ElsIf{$seq[0] = \qt{O}$}
      \Return $\qt{O}$
    \EndIf
  \EndFor
  \Return $null$
\EndProcedure
\end{algorithmic}
\end{algorithm}

The first part of our algorithm obtains all sequences of markings which, if equal to either `X' or `O', constitutes as a win for that player. Given the following grid:

\begin{verbatim}
X O X
O X O
X _ _
\end{verbatim}

The following sequences of markings should be obtained:

\begin{verbatim}
// Rows
X O X
O X O
X _ _

// Columns
X O X
O X _
X O _

// Forward Diagonal
X X X
// Backward Diagonal
X X _
\end{verbatim}

The forward diagonal is comprised of only `X'. Hence, it can be concluded that the player `X' has won.

We iterate through all these sequences which the function `getPosWinSeqs' has generated.

For each sequence, if every element in the sequence is equal to each other and equal to either `X' or `O', we return the corresponding players.

The moment a winning sequence is found, the player that has won is returned. Otherwise, the function continues to look through the list of sequences.

If no winning sequence is found, the function returns null, which indicates that the game has not finished.

In order to get the possible winning sequences, we detail out the following algorithm:

\begin{algorithm}
\caption{Obtain the possible winning sequences.}

\begin{algorithmic}[1]
\Procedure{getPosWinSeqs}{}
  \State $rows \gets this.grid$
  \For{$i \gets 0, \Call{length}{this.grid}$}
    \For{$j \gets 0, \Call{length}{this.grid}$}
      \State $cols[i][j] \gets this.grid[j][i]$
    \EndFor
  \EndFor
  \For{$i \gets 0, \Call{length}{this.grid}$}
    \State $fDiag[i] \gets this.grid[i][\Call{length}{this.grid} - i - 1]$
  \EndFor
  \For{$i \gets 0, \Call{length}{this.grid}$}
    \State $bDiag[i] \gets this.grid[i][i]$
  \EndFor
  \Return $rows + cols + [fDiag, bDiag]$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Firstly, the function sets `rows' to the grid itself. This is because the grid itself is defined as a set of rows in order.

Secondly, the function sets `cols' to the transposition of `this.grid'. The following grid:

\begin{verbatim}
O O _
X _ X
O _ X
\end{verbatim}

becomes:

\begin{verbatim}
O X O
O _ _
_ X X
\end{verbatim}

Thirdly, the function sets `fDiag' to the forward diagonal of the array and `bDiag' to the backward diagonal of the array.

Finally, the possible winning sequences are collated and returned as a two-dimensional array.

\end{document}
